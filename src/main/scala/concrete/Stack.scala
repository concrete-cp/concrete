package concrete

import concrete.heuristic.Decision

object Stack {
  def apply(head: Outcome): Stack = Stack(head, Nil, Nil, List(Seq()))
}

case class Stack(current: Outcome, leftStack: List[ProblemState], rightStack: List[Decision], decisionHistory: List[Seq[Decision]]) {
  def last: Stack = Stack(leftStack.lastOption.getOrElse(current))

  def padConstraints(problem: Problem): Stack = copy(
    current = current.andThen(_.padConstraints(problem.constraints, problem.maxCId).toState),
    leftStack = leftStack.map { s: ProblemState =>
      s.padConstraints(problem.constraints, problem.maxCId).toState
    })

  def backtrackAndApplyRightDecision: (Stack, Seq[(Variable, Event)]) = {
    val backtrackTo = rightStack.head

    val stateThen :: remainingStack = leftStack

    val decisionsThen :: remainingDecisions = decisionHistory.tail

    val history = (backtrackTo +: decisionsThen) :: remainingDecisions

    val (updated, modified) = backtrackTo(stateThen)

    (Stack(updated, remainingStack, rightStack.tail, history), modified)
  }

  /**
    *
    * @param filteredState will replace "current" state just before b1 is applied
    * @param b1 a decision to apply
    * @param b2 a decision to put on right stack
    * @return updated stack and events generated by b1
    */
  def push(filteredState: ProblemState, b1: Decision, b2: Decision): (Stack, Seq[(Variable, Event)]) = {
    val history = Seq(b1) :: decisionHistory

    val (updated, modified) = b1(filteredState)

    (Stack(updated, filteredState :: leftStack, b2 :: rightStack, history), modified)
  }

  def size: Int = leftStack.size

  def noRightStack: Boolean = rightStack.isEmpty
}
